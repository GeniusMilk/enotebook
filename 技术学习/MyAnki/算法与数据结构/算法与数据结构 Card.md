#算法与数据结构Card 
#八股文
#Anki

#C++

#参考链接 
[红黑树详解_晓之木初的博客-CSDN博客_红黑树](https://blog.csdn.net/u014454538/article/details/120120216)
```ActivityHistory
/
```

```toc
	style: bullet | number | inline (default: bullet) 
	min_depth: number (default: 2) max_depth: number (default: 6) 
	title: string (default: undefined) 
	allow_inconsistent_headings: boolean (default: false) 
	delimiter: string (default: |) 
	varied_style: boolean (default: false)
```

### 

###  第1章 绪论

#### 1.1 什么是数据结构

#### 1.2 基本概念和术语

#### 1.3 抽象数据类型的表现与实现

#### 1.4 算法和算法分析

###  第2章 线性表

#### 2.1 线性表的类型定义

#### 2.2 线性表的顺序表示和实现

#### 2.3 线性表的链式表示和实现

#### 2.4 一元多项式的表示及相加

###  第3章 栈和队列

#### 3.1 栈

#### 3.2 栈的应有和举例

#### 3.3 栈与递归的实现

#### 3.4 队列

#### 3.5 离散事件模拟

###  第4章 串

#### 4.1 串类型的定义

#### 4.2 串的表示和实现

#### 4.3 串的模式匹配算法

#### 4.4 串操作应用举例

###  第5章 数组和广义表

#### 5.1 数组的定义

#### 5.2 数组的顺序表现和实现

#### 5.3 矩阵的压缩存储

#### 5.4 广义表的定义

#### 5.5 广义表的储存结构

#### 5.6 m元多项式的表示

#### 5.7 广义表的递归算法

### 第6章 树和二叉树

#### 6.1 树的定义和基本术语

#### 6.2 二叉树

##### 6.2.1 二叉树的定义

##### 6.2.2 二叉树的性质

##### 6.2.3 二叉树的存储结构

#### 6.3 遍历二叉树和线索二叉树

##### 6.3.1 遍历二叉树

##### 6.3.2 线索二叉树

#### 6.4 树和森林

##### 6.4.1 树的存储结构

##### 6.4.2 森林与二叉树的转换

##### 6.4.3 树和森林的遍历

#### 6.5 树与等价问题

#### 6.6 赫夫曼树及其应用

##### 6.6.1 最优二叉树(赫夫曼树)

##### 6.6.2 赫夫曼编码

#### 6.7 回溯法与树的遍历

#### 6.8 树的计数

###  第7章 图

#### 7.1 图的定义和术语

#### 7.2 图的存储结构

##### 7.2.1 数组表示法

##### 7.2.2 邻接表

##### 7.2.3 十字链表

##### 7.2.4 邻接多重表

#### 7.3 图的遍历

#### 7.3.1 深度优先搜索

#### 7.3.2 广度优先搜索

#### 7.4 图的连通性问题

#### 7.4.1 无向图的连通分量和生成树

#### 7.4.2 有向图的强连通分量

##### 7.4.3 最小生成树

##### 7.4.4 关节点和重连通分量

#### 7.5 有向无环图及其应用

##### 7.5.1 拓扑排序

##### 7.5.2 关键路径

#### 7.6 最短路径

##### 7.6.1 从某个源点到其余各顶点的最短路径

##### 7.6.2 每一对顶点之间的最短路径

###  第8章 动态存储管理

#### 8.1 概述

#### 8.2 可利用空间表及分配方法

#### 8.3 边界标识法

##### 8.3.1 可利用空间表的结构

##### 8.3.2 分配算法

##### 8.3.3 回收算法

#### 8.4 伙伴系统

##### 8.4.1 可利用空间表的结构

##### 8.4.2 分配算法

##### 8.4.3 回收算法

#### 8.5 无用单元收集

#### 8.6 存储紧缩

###  第9章 查找

#### 9.1 静态查找表

#### 9.1.1 顺序表的查找

#### 9.1.2 有序表的查找

#### 9.1.3 静态树表的查找

#### 9.1.4 索引顺序表的查找

#### 9.2 动态查找表

##### 9.2.1 二叉排序树和平衡二叉树

##### 9.2.2 B树和B+树

##### 9.2.3 键树

##### 9.2.3 红黑树

###### 9.2.3.1 红黑树的引入

有了二叉搜索树，为什么还需要平衡二叉树
* ==二叉搜索树容易退化成一条链==
* 查找的时间复杂度从$O(log_2N)$ 退化成$O(N)$
* 引入对左右子树高度差有限制的平衡二叉树，保证查找操作的最坏时间复杂度也为$O(log_2N)$

有了平衡二叉树，为什么还需要红黑树？
* AVL的左右子树高度差不能超过1，每次==进行插入/删除操作时，几乎都需要通过旋转操作保持平衡==
* 在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
* 红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL
	* 红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决
* 红黑树的红黑规则，保证最坏的情况下，也能在$O(log_2N)$时间内完成查找操作。

###### 9.2.3.2 红黑规则
* 节点是红色或黑色。
* 根节点是黑色。
* 每个叶子节点都是==黑色的空节点==（NIL节点）。
* 每个红色节点的两个子节点==都是黑色==。(从每个叶子到根的所有路径上不能有==两个连续的红色节点==)
* 从任一节点到其==每个叶子的==所有路径都包含相同数目的==黑色节点==。

###### 9.2.3.3 红黑规则的理解

###### 9.2.3.3 红黑树的应用
-   Linux底层的CFS进程调度算法中，vruntime使用红黑树进行存储。
-   多路复用技术的Epoll，其核心结构是红黑树 + 双向链表。

###### 9.2.3.2 红黑树详解
#TODO

#### 9.3 哈希表

##### 9.3.1 什么是哈希表

##### 9.3.2 哈希函数的构造方法

##### 9.3.3 处理冲突的方法

##### 9.3.4 哈希表的查找及其分析

###  第10章 内部排序

#### 10.1 概述

#### 10.2 插入排序

##### 10.2.1 直接插入排序

##### 10.2.2 其他插入排序

##### 10.2.3 希尔排序

#### 10.3 快速排序

#### 10.4 选择排序

####W# 10.4.1 简单选择排序

##### 10.4.2 树形选择排序

##### 10.4.3 堆排序

#### 10.5 归并排序

#### 10.6 基数排序

####10.6.1 多关键字的排序

##### 10.6.2 链式基数排序

#### 10.7 各种内部排序方法的比较讨论

###  第11章 外部排序

#### 11.1 外存信息的存取

#### 11.2 外部排序的方法

#### 11.3 多路平衡归并的实现

#### 11.4 置换一选择排序

#### 11.5 最佳归并树

###  第12章 文件

#### 12.1 有关文件的基本概念

#### 12.2 顺序文件

#### 12.3 索引文件

#### 12.4 ISAM文件和VSAM文件

##### 12.4.1 ISAM文件

##### 12.4.2 VSAM文件

#### 12.5 直接存取文件(散列文件)

#### 12.6 多关键字文件

##### 12.6.1 多重表文件

##### 12.6.2 倒排文件