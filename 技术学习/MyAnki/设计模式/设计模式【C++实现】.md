#设计模式Card

#参考链接 
* [设计模式面试题（总结最全面的面试题！！！）_小杰要吃蛋的博客-CSDN博客_设计模式面试题](https://blog.csdn.net/weixin_43122090/article/details/105462226)
* [ C++设计模式_west_liu的博客-CSDN博客](https://blog.csdn.net/westbrookliu/article/details/83927107)

```ActivityHistory
/
```
```toc 
	style: bullet | number | inline (default: bullet) 
	min_depth: number (default: 2) max_depth: number (default: 6) 
	title: string (default: undefined) 
	allow_inconsistent_headings: boolean (default: false) 
	delimiter: string (default: |) 
	varied_style: boolean (default: false) 
```


### 1. 设计模式的分类

总体来说设计模式分为三大类
#线索 
==创建型模式==、==结构性模式==、==行为型模式==
其实还有两类：==并发型模式==、==线程池模式==
<!--SR:!2022-08-15,1,230-->

创建型模式，共五种：==工厂方法模式==、==抽象工厂模式==、==单例模式==、==建造者模式==、==原型模式==

结构型模式，共七种：==适配器模式==、==装饰器模式==、==代理模式==、==外观模式==、==桥接模式==、==组合模式==、==享元模式==

行为型模式，共十一种：==策略模式==、==模板方法模式==、==观察者模式==、==迭代子模式==、==责任链模式==、==命令模式==、==备忘录模式==、==状态模式==、==访问者模式==、==中介者模式==、==解释器模式==

<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20200411190730722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEyMjA5MA==,size_16,color_FFFFFF,t_70"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;"> 设计模式分类 </div>
</center>


### 2. 设计模式的六大原则
#### 开放封闭原则（Open Close Principle）

原则思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化
描述：一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。
优点：单一原则告诉我们，每个类都有自己负责的职责，里氏替换原则不能破坏继承关系的体系。

#### 里氏代换原则（Liskov Substitution Principle）
原则思想：使用的基类可以在任何地方使用继承的子类，完美的替换基类。
描述是：子类可以扩展父类的功能，但不能改变父类原有的功能。子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法，子类中可以增加自己特有的方法。
优点：增加程序的健壮性，即使增加了子类，原有的子类还可以继续运行，互不影响。

#### 依赖倒转原则（Dependence Inversion Principle）

原则思想：面向接口编程.

依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，

这个是开放封闭原则的基础，具体内容是：对接口编程，依赖于抽象而不依赖于具体。

#### 接口隔离原则（Interface Segregation Principle）

描述：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
例如：支付类的接口和订单类的接口，需要把这俩个类别的接口变成俩个隔离的接口

#### 迪米特法则（最少知道原则）（Demeter Principle）

原则思想：一个对象应当对其他对象有尽可能少地了解，简称类间解耦
描述：一个类尽量减少自己对其他对象的依赖，原则是低耦合，高内聚，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。
优点：低耦合，高内聚。

#### 单一职责原则（Principle of single responsibility）

原则思想：一个方法只负责一件事情。
描述：单一职责原则很简单，一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。 这是常识，几乎所有程序员都会遵循这个原则。
优点：降低类和类的耦合，提高可读性，增加可维护性和可拓展性，降低可变性的风险。





### 创建型模式

#### 工厂方法模式(Factory Method)

#####  什么是工厂模式

#####  工厂模式好处

#####  为什么要学习工厂设计模式

#####  Spring开发中的工厂设计模式

#####  工厂模式分类

######  简单工厂模式

######  工厂方法模式

######  抽象工厂模式

#### 抽象工厂模式(Abstract Factory)

#### 生成器模式(Builder)

#####  什么是建造者模式

#####  建造者模式的使用场景

#####  代码案例

#### 原型模式(Prototype)

##### 什么是原型模式

 ##### 原型模式的应用场景

 ##### 原型模式的使用方式

 ###### 原型模式分为浅复制和深复制

 ##### 代码演示
 
#### 单例模式(Singleton)

##### 1.什么是单例
保证一个类只有一个实例，并且提供==一个访问该全局访问点==

##### 2.那些地方用到了单例模式
==网站的计数器==，一般也是采用单例模式实现，否则难以同步。
==应用程序的日志应用==，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。
==多线程的线程池的设计==一般也是采用单例模式，因为线程池要方便对池中的线程进行控制
Windows的==任务管理器==就是很典型的单例模式，他不能打开俩个
windows的==回收站==也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例

##### 3.单例优缺点

###### 单例模式的优点：
在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例
单例模式具有一定的==伸缩性==，类自己来控制==实例化进程==，类就在改变实例化进程上有相应的伸缩性。
提供了对==唯一实例==的==受控访问==。
由于在系统内存中只存在一个对象，因此可以==节约系统资源==，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。
允许==可变数目的实例==。
避免对==共享资源的多重占用。==

###### 单例模式的缺点：
不适用于变化的对象，如果==同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态==。
由于单利模式中没有==抽象层==，因此单例类的==扩展有很大的困难==。
单例类的==职责过重==，在一定程度上违背了==“单一职责原==则”。
==滥用单例==将带来一些负面问题
* 如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；
* 如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。

##### 4.单例模式使用注意事项：
使用时不能用==反射模式==创建单例，否则会实例化一个新的对象
使用==懒单例模式==时注意==线程安全==问题
==饿单例模式==和==懒单例模式==构造方法都是==私有==的，因而是==不能被继承==的，有些单例模式可以被继承（如==登记式模式==）

##### 5.单例防止反射漏洞攻击
```c++
private static boolean flag = false;

private Singleton() {

	if (flag == false) {
		flag = !flag;
	} else {
		throw new RuntimeException("单例模式被侵犯！");
	}
}

public static void main(String[] args) {

}

```

##### 6.如何选择单例创建方式
不需要==延迟加载单例==，可以使用==枚举==或者==饿汉式==，相对来说枚举性好于饿汉式。  
如果需要延迟加载，可以使用==静态内部类==或者==懒汉式==，相对来说静态内部类好于懒汉式式
最好使用饿汉式

##### 7.单例创建方式特点
饿汉式:类初始化时,会==立即加载该对象==，线程天生==安全==,调用效率==高==。
懒汉式: 类初始化时,不会==初始化该对象==,真正需要使用的时候才会创建该对象,具备==懒加载功能==。
静态内部方式:结合了==懒汉式==和==饿汉式==各自的优点，==真正需要对象的时候才会加载==，加载类是线程安全的。
枚举单例: 使用枚举实现单例模式 优点:==实现简单==、==调用效率高==，==枚举==本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有==延迟加载==。
双重检测锁方式 (因为JVM本质重排序的原因，可能会初始化多次，不推荐使用)

##### 8.单例创建方式

###### 1.饿汉式

###### 2.懒汉式

###### 3.静态内部类

###### 4.枚举单例式

###### 5.双重检测锁方式
### 结构型模式

#### 适配器模式(Adapter)

#### 桥接模式(Bridge)

#### 组合模式(Composite)

#### 装饰模式(Decorator)

#### 外观模式(Facade)

#####  什么是外观模式

#####  外观模式例子

#### 享元模式(Flyweight)

#### 代理模式(Proxy)

#####  什么是代理模式

#####  代理模式应用场景

#####  代理的分类

#####  三种代理的区别

#####  用代码演示三种代理

######  静态代理

######  动态代理

######  CGLIB动态代理

### 行为型模式

#### 责任链模式(Chain of Responsibility)

#### 命令模式(Command)

#### 迭代器模式(Iterator)

#### 中介者模式(Mediator)

#### 备忘录模式(Memento)

#### 观察者模式(Observer)

##### 什么是观察者模式

##### 模式的职责

##### 观察者模式应用场景

##### 代码实现观察者模式

#### 状态模式(State)

#### 策略模式(Strategy)

##### 什么是策略模式

##### 策略模式应用场景

##### 策略模式的优点和缺点

##### 代码演示

#### 模板方法模式(Template Method)

#####  什么是模板方法

 ##### 什么时候使用模板方法

 ##### 实际开发中应用场景哪里用到了模板方法

 ##### 现实生活中的模板方法

 ##### 代码实现模板方法模式
 

#### 访问者模式(Vistor)


