 #智能指针Card

#参考链接 
* [ C++ 智能指针 - 全部用法详解_cpp_learners的博客-CSDN博客_智能指针c++](https://blog.csdn.net/cpp_learner/article/details/118912592)
[ 内存泄漏的面经_死于算法的博客-CSDN博客](https://blog.csdn.net/weixin_46642836/article/details/106181634)
* [内存泄漏的面经_死于算法的博客-CSDN博客](https://blog.csdn.net/weixin_46642836/article/details/106181634)
* [C++中的RAII技术及典型应用 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/389300115)
* [【C++】weak_ptr弱引用智能指针详解_Yngz_Miao的博客-CSDN博客_c++ weak_ptr](https://blog.csdn.net/qq_38410730/article/details/105903979#:~:text=weak_ptr%E6%98%AF%E4%B8%BA%E4%BA%86%E9%85%8D%E5%90%88shared_ptr%E8%80%8C%E5%BC%95%E5%85%A5%E7%9A%84%E4%B8%80%E7%A7%8D%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%8C,%E5%AE%83%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E7%94%B1shared_ptr%E7%AE%A1%E7%90%86%E7%9A%84%E5%AF%B9%E8%B1%A1%E8%80%8C%E4%B8%8D%E5%BD%B1%E5%93%8D%E6%89%80%E6%8C%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%EF%BC%8C%E5%B0%86%E4%B8%80%E4%B8%AAweak_ptr%E7%BB%91%E5%AE%9A%E5%88%B0%E4%B8%80%E4%B8%AAshared_ptr%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98shared_ptr%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E3%80%82%20%E4%B8%8D%E8%AE%BA%E6%98%AF%E5%90%A6%E6%9C%89weak_ptr%E6%8C%87%E5%90%91%EF%BC%8C%E4%B8%80%E6%97%A6%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84shared_ptr%E8%A2%AB%E9%94%80%E6%AF%81%EF%BC%8C%E5%AF%B9%E8%B1%A1%E5%B0%B1%E4%BC%9A%E8%A2%AB%E9%87%8A%E6%94%BE%E3%80%82)
* [常见的内存泄漏原因及解决方法 - 简书 (jianshu.com)](https://www.jianshu.com/p/90caf813682d)
* [C/C++内存泄漏常见情况分析_天有行-地无迹-千秋怎堪一剑扫的博客-CSDN博客_c++内存泄漏分析](https://blog.csdn.net/weitaming1/article/details/112545515#:~:text=%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AAc%2Fc%2B%2B%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B9%9F%E6%98%AF%E4%BB%A4%E4%BA%BA%E5%A4%B4%E7%96%BC%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82%20%E5%B7%B2%E7%BB%8F%E6%9C%89%E8%AE%B8%E5%A4%9A%E6%8A%80%E6%9C%AF%E8%A2%AB%E7%A0%94%E7%A9%B6%E5%87%BA%E6%9D%A5%E4%BB%A5%E5%BA%94%E5%AF%B9%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E6%AF%94%E5%A6%82%20Smart,Pointer%EF%BC%8CGarbage%20Collection%20%E7%AD%89%E3%80%82)
```ActivityHistory
/
```
```toc 
	style: bullet | number | inline (default: bullet) 
	min_depth: number (default: 2) max_depth: number (default: 6) 
	title: string (default: undefined) 
	allow_inconsistent_headings: boolean (default: false) 
	delimiter: string (default: |) 
	varied_style: boolean (default: false) 
```

### 1.为什么需要智能指针（智能指针场景）
[[C++ Card#（58）为什么C 没有实现垃圾回收？|C++没有垃圾回收机制]]，`new/delete`等等出来的资源，需要手动释放。
而手动释放可能会产生：
#线索 
* 忘记释放
* 发生异常安全问题

两种情况最终都导致[[|资源泄漏]]，也是智能指针的产生场景。

### 2.内存泄漏

#### 2.1 内存泄漏(Memory leak)
##### 2.1.1 内存泄漏的定义
内存泄漏指由于==疏忽或错误造成程序未能释放已经不再使用的内存的情况==。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。
##### 2.1.2 内存泄漏的产生
<!--SR:!2022-09-06,13,213-->

#### 2.2 内存泄漏的危害

#### 2.3 内存泄漏分类
##### 2.3.1 内存泄漏的情况

#### 2. 4 解决内存泄漏相关问题


#### 2.1什么是内存泄漏

#### 2.2内存泄漏的危害
内存泄漏是==造成应用程序OOM（程序申请内存过大，程序捕获异常弹窗失败）==的主要原因之一。我们知道系统为每个应用程序分配的内存是有限的，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过系统分配的内存限额。
<!--SR:!2022-09-06,13,210-->

#### 2.3 内存泄漏分类(了解)
#####  2.3.1 以发生的方式来分类：  
==常发性内存泄漏==、==偶发性内存泄漏==、==一次性内存泄漏==、==隐式内存泄漏==
<!--SR:!2022-09-14,17,193!2022-09-07,10,208!2022-09-11,14,228!2022-09-06,9,208-->

######  2.3.1.1 常发性内存泄漏。
发生内存泄漏的代==码会被多次执行到，每次被执行的时候都会导致一块内存泄漏==。比如例二，如果Something()函数一直返回True，那么pOldBmp指向的HBITMAP对象总是发生泄漏。  
<!--SR:!2022-09-08,16,230-->

######  2.3.1.2. 偶发性内存泄漏
发生内存泄漏的代==码只有在某些特定环境或操作过程下才会发生==。比如例二，如果Something()函数只有在特定环境下才返回 True，那么pOldBmp指向的HBITMAP对象并不总是发生泄漏。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以 [测试](http://lib.csdn.net/base/softwaretest)环境和测试方法对检测内存泄漏至关重要。  
<!--SR:!2022-09-05,12,209-->

######  2.3.1.3. 一次性内存泄漏
发生内存泄漏的代==码只会被执行一次，或者由于[算法](http://lib.csdn.net/base/datastructure)上的缺陷，导致总会有一块仅且一块内存发生泄漏==。比如，在类的构造函数中分配内存，在析 构函数中却没有释放该内存，但是因为这个类是一个Singleton，所以内存泄漏只会发生一次。另一个例子：
<!--SR:!2022-09-02,10,197-->

######  2.3.1.4. 隐式内存泄漏
程序在运行过程中不停的分配内存，但是==直到结束的时候才释放内存==。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但 是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。
<!--SR:!2022-09-02,7,214-->

##### 2.3.2 堆内存泄漏（Heap leak）

##### 2.3.3 系统资源泄漏

#### 2.4 常见资源泄漏
1、==单例==造成的内存泄漏
2、==非静态内部类创建静态实例==造成的内存泄漏
3、==Handler==造成的内存泄漏
4、==线程==造成的内存泄漏
5、==资源未关闭==造成的内存泄漏
6、使用ListView时造成的内存泄漏
7、==集合容器==中的内存泄露
<!--SR:!2022-08-30,2,130!2022-08-30,1,130!2022-08-30,1,142!2022-08-31,3,182!2022-08-30,1,142!2022-08-30,1,142-->

##### 2.4.1 单例造成的内存泄漏
##### 2.4.2 非静态内部类创建静态实例造成的内存泄漏
##### 2.4.3 Handler造成的内存泄漏
##### 2.4.4 线程造成的内存泄漏
##### 2.4.5 资源未关闭造成的内存泄漏
##### 2.4.6 使用ListView时造成的内存泄漏
##### 2.4.7 集合容器中的内存泄露

#### 2.5 内存泄漏的排查
因为内存泄漏是在[[C++ Card#（2） 堆和栈有什么区别|堆内存]]中，所以对我们来说==并不是可见==的。通常我们可以借助[[|MAT]]、[[TODOLeakCanary|LeakCanary]]等工具来检测应用程序是否存在内存泄漏。
<!--SR:!2022-08-30,4,210-->

#### 2.6 内存泄漏的避免
对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期（面试时回答注意==软件生命周期及时摧毁和释放==）。  
将内部类改为静态内部类，静态内部类中使用弱引用来引用外部类的成员变量（面试回答将==一些类转化为静态内部类==）
<!--SR:!2022-09-07,13,217!2022-09-04,7,194-->

### 3. 智能指针的使用及原理

#### 3.1RAII
##### 3.1.1 RAII 的定义
RAII（**R**esource **A**cquisition **I**s **I**nitialization）中文翻译为==资源获取即初始==化 是一种利用局部对象生命周期来控制==程序资源（如内存、文件句柄、网络连接、互斥量等等)==的技术，==局部对象==是指==存储在栈的对象==，它的生命周期是由操作系统来管理的，无需人工介入；
<!--SR:!2022-09-06,9,180!2022-09-02,7,214!2022-09-06,13,214!2022-09-03,6,193-->

##### 3.1.2 RAII 的原理
###### 3.1.2.1 资源使用的步骤
#线索 
a.获取资源 b.使用资源 c.销毁资源，

###### 3.1.2.2 RAII 步骤
RAII，它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期，可以总结为四个步骤
	a.设计一个类封装资源
	b.在构造函数中初始化
	c.在析构函数中执行销毁操作
	d.使用时声明一个该对象的类

##### 3.1.3 RAII 的收益
-   不需要==显式地释放资源。==
-   采用这种方式，对象所需的资源在==其生命期内始终保持有效==
<!--SR:!2022-09-10,15,220!2022-09-03,9,217-->

##### 3.1.4 RAII 思想的应用
？
#线索 
资源管理、状态管理

**在资源管理方面**，==智能指针(`std\:\:shared_ptr`和`std\:\:unique_ptr`)是`RAII`最具代表性的实现==，使用了智能指针，可以实现自动的内存管理，再也不用担心忘记`delete`造成内存泄漏了。
**在状态管理方面**，==[[OS Card#线程间的同步|线程同步]]中lock_guard类使用`std\:\:unique_lock`或`std\:\:lock_guard`对互斥量`std\:\:mutex`进行状态管理也是`RAII`的典型实现==通过这种方式，我们再也不用担心互斥量之间的代码出现异常而造成线程死锁。
<!--SR:!2022-09-02,5,170!2022-09-02,7,210-->

#### 3.2 智能指针的原理
##### 3.2.1 智能指针的原理
```c++
#include"SmartPtr.hpp"
//智能指针的坑
int main()
{
    SmartPtr<int> sp(new int);
    SmartPtr<int> sp2 = sp;
    return 0;
}
```
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/img_convert/0cede9f0b9574ccc804f7d79489affe8.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">  第一级配置器 UML </div>

</center>
STL如[[STL详解及常见面试题|string]]，[[STL详解及常见面试题|vector]]是该对象本身拥有资源空间；
智能指针只是受人托管资源空间，可以访问空间，模拟的是原生指针行为，比原生指针多了在生命周期结束时可以释放资源的功能。两者行为不同，智能指针需要的行为就是指向同一块资源。因此智能指针不能采用[[C++ Card#（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）|深拷贝]]方式解决。

##### 3.2.2 C++ 的应对
* ==管理权转移==（C++98 `auto_ptr`)
* ==防拷贝== （C++11 `unique_ptr`）
* ==引用计数的共享拷贝== （C++11 `shared_ptr`）
* 循环引用的问题，又需要`weak_ptr`来解决
<!--SR:!2022-08-31,2,150!2022-08-30,2,135!2022-09-06,11,215-->

#### 3.3 auto_ptr

##### 3.3.1 auto_ptr 的原理
`auto_ptr`采用管理权转移进行处理

##### 3.3.2 auto_ptr 的缺陷：
ap2=ap1场景下ap1就悬空了，访问就会报错。
管理权转移是早期设计缺陷，一般禁止使用它。

#### 3.4 unique_ptr

##### 3.4.1 unique_ptr特性
-   基于排他所有权模式：==两个指针不能指向同一个资源==
-   无法进行==左值unique_ptr复制构造==，也无法进行==左值复制赋值操作==，但允许临时==右值赋值构造和赋值==
-   保存指向某个对象的指针，当它==本身离开作用域时会自动释放它指向的对==象。
-   在==容器中保存指针==是安全的
<!--SR:!2022-08-30,2,130!2022-08-30,2,166!2022-08-30,4,186!2022-08-31,2,186!2022-08-30,2,166!2022-09-01,4,166-->

##### 3.4.2 unique_ptr如何实现“独占”所指对象
因为unique_ptr本质是类 ，因此可将`copy constructor`和`copy assignment`声明为delete即可（获取将其变为private属性且不去实现它也行）;
同时我们需要实现移动构造和移动赋值，以供某些特定场合使用。

##### 3.4.3 unique_ptr 的缺陷：
unique_ptr==不可拷贝，但是可以移动==。
如果有[[C++ Card#（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）|拷贝]]需要，也就是实现==移动构造和移动赋值== 的场景，unique_ptr 就没法使用。
<!--SR:!2022-09-01,4,177!2022-09-08,14,217-->

##### 3.4.4 手搓unique_ptr ：
#TODO
[面试官的动机——实现智能指针1：unique_ptr - 简书 (jianshu.com)](https://www.jianshu.com/p/77c2988be336)

#### 3.5shared_ptr
核心想法：==引用计数是记录有多少个对象共同管理着资源，最后一个析构资源==。
<!--SR:!2022-09-13,18,230-->

##### 3.5.1 shared_ptr 原理
是通过==引用计数==的方式来实现多个shared_ptr对象之间共享资源
<!--SR:!2022-09-25,27,250-->

* shared_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共享。
* 在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一。
* 如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源；
* 如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了。


##### 3.5.2 shared_ptr 的缺陷
==线程安全==、==循环引用==
<!--SR:!2022-08-30,4,210!2022-09-01,4,194-->

###### 3.5.2.1 shared_ptr 线程安全
(1)智能指针对象中引用计数是多个智能指针对象共享的，==两个线程中智能指针的引用计数同时++或--，这个操作不是原子的，引用计数原来1，++了两次，可能还是2。这样引用计数就错乱了==。会导致资源未释放或者程序崩溃的问题。所以只能指针中引用计数++、--是需要加锁的，也就是说引用计数的操作需要是线程安全的。
(2)智能指针管理的对象==存放在堆上，两个线程中同时去访问，会导致线程安全问题==
<!--SR:!2022-09-03,8,189!2022-09-06,9,189-->

###### 3.6.2.2 shared_ptr 循环引用
?
两个对象相互使用shared_ptr成员变量指向对方造成循环引用，导致引用计数失效
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20200503151929866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDEwNzMw,size_16,color_FFFFFF,t_70#pic_center"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">   shared_prt 循环引用 </div>
<!--SR:!2022-09-06,14,237-->

</center>


###### 3.5.2.3 shared_ptr 解决循环引用：
`weak_ptr`的出现就是**为了解决shared_ptr的循环引用的问题的**。以上文的例子来说，解决办法就是将==两个类中的一个成员变量改为weak_ptr对象==
<!--SR:!2022-08-31,9,217-->

##### 3.5.3  手搓 shared_ptr 
[(手撕c++ shared_ptr（字节跳动手写算法）_Michealzn的博客-CSDN博客](https://blog.csdn.net/m0_38076911/article/details/107071006)

注意：面试的时候会考察手写`shared_ptr`。

`静态变量计数器不能解决问题`

#### 3.6 weak_ptr
##### 3.6.1 weak_ptr 的实质
严格来说`weak_ptr`==不是智能指针，因为他没有RAII==。专用来解决`shared_ptr`的循环引用问题。
<!--SR:!2022-09-03,9,217-->

##### 3.6.2 weak_ptr 的原理就是，
`node1->_next = node2`;和`node2->_prev = node1`;时`weak_ptr`的`_next`和`_prev`不会增加`node1`和`node2`的引用计数。

##### 3.6.3 weak_ptr 如何使用

###### 3.6.3.1 weak_ptr初始化方式
?
* 通过shared_ptr直接初始化，也可以通过[[|隐式转换]]来构造；
* 允许移动构造，也允许拷贝构造。
<!--SR:!2022-08-30,4,210-->


######  3.6.3.2 weak_ptr 常用操作
?
-   w.user_count()：返回weak_ptr的强引用计数；
-   w.reset(…)：重置weak_ptr。
<!--SR:!2022-09-05,10,210-->

##### 3.6.4 如何判断weak_ptr指向对象是否存在？
既然weak_ptr并不改变其所共享的shared_ptr实例的引用计数，那就可能==存在`weak_ptr`指向的对象被释放掉这种情况==。这时，就不能使用`weak_ptr`直接访问对象。那么如何判断`weak_ptr`指向对象是否存在呢？==C++中提供了lock函数来实现该功能。==如果对象存在，lock()函数返回一个指向共享对象的shared_ptr(引用计数会增1)，否则返回一个空shared_ptr。weak_ptr还提供了==expired()函数来判断所指对象是否已经被销毁。==
<!--SR:!2022-09-08,11,190!2022-09-07,10,213!2022-09-01,7,209-->

##### 3.6.5 weak_pt 使用场景
==共享对象==的线程安全问题
==观察者==模式
监视==this智能指针==
解决==循环引用==
<!--SR:!2022-09-02,5,153!2022-08-30,4,202!2022-08-31,3,182!2022-08-30,4,202-->

###### 3.6.5.1 共享对象的线程安全问题
想访问对象的方法，先通过t的lock方法进行提升操作，把weak_ptr提升为shared_ptr强智能指针。提升过程中，是通过检测它所观察的强智能指针保存的Test对象的引用计数，来判定Test对象是否存活。ps如果为nullptr，说明Test对象已经析构，不能再访问；如果ps!=nullptr，则可以正常访问Test对象的方法。


###### 3.6.5.2 [[设计模式【C++实现】#观察者模式 Observer|观察者模式]]
一个用C++写的开源网络库，muduo库，作者陈硕
借助shared_ptr和weak_ptr解决了这样一个问题，多线程访问共享对象的线程安全问题。

 [[设计模式【C++实现】#观察者模式 Observer|观察者模式]]通常都在另一个独立的线程中，这就涉及到在多线程环境中，共享对象的线程安全问题(解决方法就是使用上文的智能指针)。这是因为在==找到监听者并让它处理事件时，其实在多线程环境中，肯定不明确此时监听者对象是否还存活，或是已经在其它线程中被析构了==，此时再去通知这样的监听者，肯定是有问题的。
```c++
// 存储监听者注册的感兴趣的事件
unordered_map<int, list<weak_ptr<Listener>>> listenerMap;

// 观察者观察到事件发生，转发到对该事件感兴趣的监听者
void dispatchMessage(int msgid) {
  auto it = listenerMap.find(msgid);
  if (it != listenerMap.end()) {
    for (auto it1 = it->second.begin(); it1 != it->second.end(); ++it1) {
      shared_ptr<Listener> ps = it1->lock();            // 智能指针的提升操作，用来判断监听者对象是否存活
      if (ps != nullptr) {                              // 监听者对象如果存活，才通知处理事件
        ps->handleMessage(msgid);
      } else {
        it1 = it->second.erase(it1);                    // 监听者对象已经析构，从map中删除这样的监听者对象
      }
    }
  }
}

```
<!--SR:!2022-09-04,6,160-->

###### 3.6.5.3 监视this智能指针
`enable_shared_from_this`中有一个弱指针`weak_ptr`，这个弱指针能够监视this。在调用`shared_from_this`这个函数时，这个函数内部实际上是调用`weak_ptr`的`lock()`方法。`lock()`会让shared_ptr指针计数+1，同时返回这个shared_ptr。

###### 3.6.5.4 解决循环引用

### 4.智能指针的历史

### 5.定制删除器(了解)
分析：C++11中没有xxx_array版本，那么如果是new[]出来的对象要怎么办？
析构默认都是`delete`，但是如果需要的删除方式不是delete，可以定制删除器，==调用仿函数对指针进行释放。实际上定制删除器就是传一个实现释放方法仿函数对象进去给智能指针==
<!--SR:!2022-09-03,6,157-->

### 6.RAII的扩展学习：lock_guard
