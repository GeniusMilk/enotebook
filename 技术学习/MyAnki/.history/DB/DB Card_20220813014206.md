#DBCard
#八股文
#Anki

#myanki

```ActivityHistory
/
```
```toc 
	style: bullet | number | inline (default: bullet) 
	min_depth: number (default: 2) max_depth: number (default: 6) 
	title: string (default: undefined) 
	allow_inconsistent_headings: boolean (default: false) 
	delimiter: string (default: |) 
	varied_style: boolean (default: false) 
```


# 数据库
## 1.关系型数据库非关系型数据库
### 1.1 关系型数据库
### 1.1.1 关系型数据库的定义
### 1.1.2 关系型数据库的优缺点


 关系型数据库的优点
?
  1. 容易理解。因为它采用了关系模型来组织数据。
  2. 可以保持数据的一致性。
  3. 数据更新的开销比较小。
  4. 支持复杂查询（带where子句的查询） <!--SR:!2022-08-15,4,190-->

### 1.2 非关系型数据库
### 1.2.1 非关系型数据库的定义

定义
?
非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。 <!--SR:!2022-08-27,17,248-->

### 1.2.2 非关系型数据库的优缺点

非关系型数据库的优点
?
  1. 不需要经过sql层的解析，读写效率高。
  2. 基于键值对，数据的扩展性很好。
  3. 可以支持多种类型数据的存储，如图片，文档等等。 <!--SR:!2022-08-13,3,168-->

#### 1.2.3 适合使用非关系型数据库的场景：
四类场景
?
* 日志系统
* 地理位置存储
* 数据量巨大
* 高可用  <!--SR:!2022-08-20,10,208-->

## 2. 数据库索引
### 2.1索引类型
#### 2.1.1 两种类型

#线索 
?
数据库的索引类型分为逻辑分类和物理分类 <!--SR:!2022-08-22,11,224-->

#### 2.1.2 逻辑分类

#线索 
?
主键索引、唯一索引、普通索引、全文索引 <!--SR:!2022-08-15,4,184-->

逻辑分类：
* 主键索引 ::当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。 <!--SR:!2022-08-13,3,224-->
* 唯一索引 ::数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。 <!--SR:!2022-08-22,11,224-->
* 普通索引 ::一张表可以有多个普通索引，可以重复可以为空值 <!--SR:!2022-08-15,4,184-->
* 全文索引 ::可以加快模糊查询，不常用 <!--SR:!2022-08-21,9,204-->

#### 2.1.3 物理分类：

#线索 
?
聚集索引、非聚集索引 <!--SR:!2022-08-26,16,244-->

物理分类
* 聚集索引（聚簇索引） ::数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。 <!--SR:!2022-08-13,1,130-->
* 非聚集索引 ::数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据 <!--SR:!2022-08-13,2,164-->

### 2.2 索引的优缺点
#重点
#### 2.2.1 索引的优缺点

##### 2.2.1,1 创建索引可以大大提高系统的性能。
?
第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 <!--SR:!2022-08-13,1,130-->

##### 2.2.1,2 增加索引的缺点
?
第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 <!--SR:!2022-08-16,4,203-->

#### 2.2.2 索引适用与不适用的场景

适合建立索引的的列
?
* 经常搜索的列上建索引
* 作为主键的列上要建索引
* 经常需要连接（where子句）的列上
* 经常需要排序的列
* 经常需要范围查找的列 <!--SR:!2022-08-13,1,130-->

哪些列不适合建索引
?
* 很少查询的列
* 更新很频繁的列
* 数据值的取值比较少的列（比如性别 <!--SR:!2022-08-13,2,163-->

### 2.3 索引的实现
#重点
#### 2.3.1 索引的底层实现【重点】
##### 2.3.1.1 索引的底层实现
##### 2.3.1.2 为什么使用B+ tree 

###### 2.3.1.2.1 什么是B+tree
线索
?
结构、数据位置、扫库、适用于区间查询 <!--SR:!2022-08-13,1,130-->

Btree的优点
?
由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。 <!--SR:!2022-08-13,1,130-->

###### 2.3.1.2.2   B树和B+树的区别
这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。
#线索 
?
1. 关键字的数量不同；
2. 存储的位置不同；
3. 分支结点的构造不同
4. 查询不同 <!--SR:!2022-08-13,1,130-->

这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。
1. 关键字的数量不::B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。 <!--SR:!2022-08-14,3,163-->
2. 存储的位置不同::B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。 <!--SR:!2022-08-21,11,223-->
3. 分支结点的构造不同::B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。 <!--SR:!2022-08-13,2,163-->
4. 查询不同::B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。 <!--SR:!2022-08-13,1,143-->

##### 2.3.1.2 红黑树相关
#TODO
##### 2.3.1.3 B树相关
#TODO

#重点
### 2.4 MySQL 索引相关

#### 2.4.1 索引最左前缀/最左匹配
#TODO 详细学习
假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。

## 3.数据库事务

<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181122103402725-726722235.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">ACID理解</div>
</center>

### 3.1 事务的定义与实现、

#### 3.1.1 事务的定义

定义：::数据库事务是构成单一逻辑工作单元的操作集合 <!--SR:!2022-08-21,12,244-->

事务定义推知：
#考点
?
-   1.数据库事务可以包含一个或多个数据库操作,但这些操作构成一个逻辑上的整体。
-   2.构成逻辑整体的这些数据库操作,要么全部执行成功,要么全部不执行。
-   3.构成事务的所有操作,要么全都对数据库产生影响,要么全都不产生影响,即不管事务是否执行成功,数据库总能保持一致性状态。
-   4.以上即使在数据库出现故障以及并发事务存在的情况下依然成立。 <!--SR:!2022-08-27,17,244-->

事务存在的目的：
?
事务使系统能够更方便的进行故障恢复以及并发控制,从而保证数据库状态的一致性。 <!--SR:!2022-08-13,4,184-->

#### 3.1.2  事务的ACID特性以及实现原理概述
##### 3.1.2.1 ACID
ACID定义：
#线索 
?
原子性【A】一致性【C】隔离性【I】持久性【D】 <!--SR:!2022-08-23,14,244-->

原子性(Atomicity)：::事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。 <!--SR:!2022-09-01,20,264-->

一致性(Consistency)：::事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。一致性状态是指:1.系统的状态满足数据的完整性约束(主码,参照完整性,check约束等) 2.系统的状态反应数据库本应描述的现实世界的真实状态,比如转账前后两个账户的金额总和应该保持不变。 <!--SR:!2022-08-13,4,184-->

隔离性(Isolation)：::并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的结果一样。 <!--SR:!2022-08-15,4,204-->

持久性(Durability)：::事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。 <!--SR:!2022-08-22,13,244-->

##### 3.1.2.1 ACID 的主要威胁
ACID主要威胁：
#线索 
?
-   1.事务的并发执行
-   2.事务故障或系统故障 <!--SR:!2022-08-14,2,204-->

ACID 的规避措施
#线索 
并发控制技术和日志恢复技术来避免这种情况发生的。

ACID针对的问题
?
并发控制: 隔离性、一致性
日志恢复：一致性、持久性、原子性 <!--SR:!2022-08-13,3,159-->

#图片辅助记忆
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181122103102223-1059881337.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">ACID理解</div>
</center>

### 3.2 并发异常与并发控制技术
[数据库事务的概念及其实现原理 - takumiCX - 博客园](https://www.cnblogs.com/takumicx/p/9998844.html)

#### 3.2.1 常见并发异常
常见并发异常：
#线索 
?
脏写、脏读、丢失更新、不可重复读、幻读
<!--SR:!2022-08-13,1,154-->

##### 3.2.1.1  脏写

#定义
?
脏写是指事务回滚了其他事务对数据项的已提交修改 <!--SR:!2022-08-16,4,179-->

#图片辅助记忆 
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
	 src="https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181122103114390-240225061.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">脏写</div>
</center>

规避措施


##### 3.2.1.2  更新丢失

#定义
?
丢失更新是指事务覆盖了其他事务对数据的已提交修改 <!--SR:!2022-08-15,4,179-->

#图片辅助记忆 
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
	 src="https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181122103128561-1407249708.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">丢失更新</div>
</center>

规避措施


##### 3.2.1.3 脏读

#定义
?
脏读是指一个事务读取了另一个事务未提交的数据 <!--SR:!2022-08-15,4,199-->

#图片辅助记忆 
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
	 src="https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181122103137124-343962409.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">脏读</div>
</center>

规避措施


##### 3.2.1.4  不可重复读

#定义
?
不可重复读是指一个事务对同一数据的读取结果前后不一致。 <!--SR:!2022-08-20,11,219-->

#图片辅助记忆 
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
	 src="https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181122103147288-996731595.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">不可重复读</div>
</center>

规避措施



##### 3.2.1.5  幻读
#定义
?
幻读是指事务读取某个范围的数据时，因为其他事务的操作导致前后两次读取的结果不一致 <!--SR:!2022-08-20,10,199-->

#图片辅助记忆 
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
	 src="https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181122103158043-533492513.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">幻读</div>
</center>

规避措施


##### 3.2.2 并发处理汇总

##### 3.2.2.1 一些对比

###### 3.2.2.1.1 脏读和不可重复读的区别
?
脏读和不可重复读的区别在于:前者读取的是事务未提交的脏数据,后者读取的是事务已经提交的数据,只不过因为数据被其他事务修改过导致前后两次读取的结果不一 <!--SR:!2022-08-13,4,179-->

###### 3.2.2.1.2 幻读和不可重复读的区别
?
幻读和不可重复读的区别在于,不可重复读是针对确定的某一行数据而言,而幻读是针对不确定的多行数据。因而幻读通常出现在带有查询条件的范围查询中 <!--SR:!2022-08-13,4,179-->

#### 3.2.2 事务的隔离级别

##### 3.2.2.1 为何会有隔离级别

##### 3.2.2.2 隔离级别的影响
?
事务的隔离级别越低,可能出现的并发异常越多,但是通常而言系统能提供的并发能力越强 <!--SR:!2022-08-13,9,259-->

##### 3.2.2.3 SQL标准 定义的不同隔离级别

#线索 
?
-   读未提交(READ UNCOMMITTED)
-   读已提交(READ COMMITTED)
-   可重复读(REPEATABLE READ)
-   串行化(SERIALIZABLE) <!--SR:!2022-08-20,11,219-->

###### 3.2.2.3.1  读未提交(READ UNCOMMITTED)
###### 3.2.2.3.2 读已提交(READ COMMITTED)
###### 3.2.2.3.3  可重复读(REPEATABLE READ)
###### 3.2.2.3.4  串行化(SERIALIZABLE)
###### 3.2.2.3.5 不同隔离几倍可能导致的并发异常汇总
#线索 
?
事务隔离级别都不允许出现脏写,而串行化可以避免所有可能出现的并发异常,但是会极大的降低系统的并发处理能力。 <!--SR:!2022-08-30,18,239-->

#图片辅助记忆 
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
	 src="https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181122103221352-219869675.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">不同隔离级别可能导致的并发异常汇总</div>
</center>
这种对应关系只是理论上的,对于特定的数据库实现不一定准确,比如mysql  
的Innodb存储引擎通过Next-Key Locking技术在可重复读级别就消除了幻读的可能。

#### 3.2.3 事务隔离性的实现--常见并发控制技术
##### 3.2.3.1 乐观并发控制和悲观并发控制

#线索 
并发控制技术是实现事务隔离性以及不同隔离级别的关键,实现方式有很多,按照其对可能冲突的操作采取的不同策略可以分为==乐观并发控制和悲观并发控制==两大类。 <!--SR:!2022-08-21,9,219-->

###### 3.2.3.1.1 乐观并发控制
#定义 
-   乐观并发控制::对于并发执行可能冲突的操作,假定其不会真的冲突,允许并发执行,直到真正发生冲突时才去解决冲突,比如让事务回滚。 <!--SR:!2022-08-23,14,239-->
    

###### 3.2.3.1.2 悲观并发控制

#定义
-   悲观并发控制::对于并发执行可能冲突的操作,假定其必定发生冲突,通过让事务等待(锁)或者中止(时间戳排序)的方式使并行的操作串行执行。 <!--SR:!2022-08-22,13,239-->

##### 3.2.3.2 并发控制技术

#线索 
?
基于锁的并发控制、基于时间戳的并发控制、基于有效性的并发控制、基于快照隔离的并发控制 <!--SR:!2022-08-13,2,199-->

###### 3.2.3.2.1 基于锁的并发控制

核心思想
?
对于并发可能冲突的操作,比如读-写,写-读,写-写,通过锁使它们互斥执行 <!--SR:!2022-08-22,13,239-->

特点
#线索 
两种类型的锁
?
锁通常分为共享锁和排他锁两种类型 <!--SR:!2022-08-13,1,159-->

-   1.[[DB Card#共享锁^定义|共享锁]]](S)::事务T对数据A加共享锁,其他事务只能对A加共享锁但不能加排他锁。 <!--SR:!2022-08-19,9,199-->

-   2.[[DB Card#排他锁|排他锁]](X)::事务T对数据A加排他锁,其他事务对A既不能加共享锁也不能加排他锁 <!--SR:!2022-08-23,14,239-->

基于锁的并发控制流程：
?
1.  事务根据自己对数据项进行的操作类型申请相应的锁(读申请共享锁,写申请排他锁)
2.  申请锁的请求被发送给锁管理器。锁管理器根据当前数据项是否已经有锁以及申请的和持有的锁是否冲突决定是否为该请求授予锁。
3.  若锁被授予,则申请锁的事务可以继续执行;若被拒绝,则申请锁的事务将进行等待,直到锁被其他事务释放。 <!--SR:!2022-08-15,4,199-->

基于锁的并发控制可能存在的问题
#线索 
?
饥饿、[[Linux Card#死锁|死锁]] <!--SR:!2022-08-26,16,239-->

1.[[Linux Card#死锁|死锁]] ::多个事务持有锁并互相循环等待其他事务的锁导致所有事务都无法继续执行。 <!--SR:!2022-08-25,15,239-->

2.饥饿::数据项A一直被加共享锁,导致事务一直无法获取A的排他锁 <!--SR:!2022-08-19,7,219-->

基于锁的并发管理分类
?
,锁使它们由并行变为串行执行,是一种悲观的并发控制。 <!--SR:!2022-08-25,15,239-->

###### 3.2.3.2.1 基于时间戳的并发控制

核心思想
?
对于并发可能冲突的操作,基于时间戳排序规则选定某事务继续执行,其他事务回滚。 <!--SR:!2022-08-24,14,239-->

两个时间戳相关字段
?
每一个数据项Q有两个时间戳相关的字段:  
W-timestamp(Q)::成功执行write(Q)的所有事务的最大时间戳   <!--SR:!2022-08-20,8,219-->
R-timestamp(Q)::成功执行read(Q)的所有事务的最大时间戳 <!--SR:!2022-08-24,14,239-->

时间戳排序规则
？
1.  假设事务T发出read(Q),T的时间戳为TS  
    a.若TS(T)<W-timestamp(Q),则T需要读入的Q已被覆盖。此  
    read操作将被拒绝,T回滚。  
    b.若TS(T)>=W-timestamp(Q),则执行read操作,同时把  
    R-timestamp(Q)设置为TS(T)与R-timestamp(Q)中的最大值
2.  假设事务T发出write(Q)  
    a.若TS(T)<R-timestamp(Q),write操作被拒绝,T回滚。  
    b.若TS(T)<W-timestamp(Q),则write操作被拒绝,T回滚。  
    c.其他情况:系统执行write操作,将W-timestamp(Q)设置  
    为TS(T)。

基于时间戳的并发控制的分类
?
基于时间戳排序和基于锁实现的本质一样:对于可能冲突的并发操作,以串行的方式取代并发执行,因而它也是一种悲观并发控制。 <!--SR:!2022-08-26,16,239-->

###### 3.2.3.2.1 基于有效性检查的并发控制

核心思想
?
事务对数据的更新首先在自己的工作空间进行,等到要写回数据库时才进行有效性检查,对不符合要求的事务进行回滚。 <!--SR:!2022-08-20,11,219-->

基于有效性检查的并发控制的过程
#线索 
?
读阶段、有效性检查阶段、写阶段 <!--SR:!2022-08-24,14,239-->

基于有效性检查的并发控制的过程
1.  读阶段::数据项被读入并保存在事务的局部变量中。所有write操作都是对局部变量进行,并不对数据库进行真正的更新。 <!--SR:!2022-08-20,10,199-->
2.  有效性::检查阶段:对事务进行有效性检查,判断是否可以执行write操作而不违反可串行性。如果失败,则回滚该事务。 <!--SR:!2022-08-16,4,179-->
3.  写阶段::事务已通过有效性检查,则将临时变量中的结果更新到数据库中。 <!--SR:!2022-08-20,11,219-->

基于有效性检查的并发控制的分类
?
该方法允许可能冲突的操作并发执行,因为每个事务操作的都是自己工作空间的局部变量,直到有效性检查阶段发现了冲突才回滚。因而这是一种乐观的并发策略。 <!--SR:!2022-08-26,16,239-->

###### 3.2.3.2.1 基于快照隔离的并发控制
#线索 
?
快照隔离是多版本并发控制(mvcc)的一种实现方式。 <!--SR:!2022-08-21,12,239-->

核心思想
?
据库为每个数据项维护多个版本(快照),每个事务只对属于自己的私有快照进行更新,在事务真正提交前进行有效性检查,使得事务正常提交更新或者失败回滚。 <!--SR:!2022-08-15,4,199-->

如何避免更新丢失
?
- 先提交者获胜:对于执行该检查的事务T,判断是否有其他事务已经将更新写入数据库,是则T回滚否则T正常提交。
- 先更新者获胜:通过锁机制保证第一个获得锁的事务提交其更新,之后试图更新的事务中止。 <!--SR:!2022-08-13,1,130-->

基于快照隔离的并发控制的分类
?
事务间可能冲突的操作通过数据项的不同版本的快照相互隔离,到真正要写入数据库时才进行冲突检测。因而这也是一种乐观并发控制。 <!--SR:!2022-08-13,9,259-->

###### 3.2.3.2.1 并发控制技术总结

基于锁的并发控制对比基于时间戳的并发控制
#线索 
?
如何处理冲突、排序规则 <!--SR:!2022-08-31,19,239-->

基于锁的并发控制对比基于时间戳的并发控制
?
-   基于锁是让冲突的事务进行等待,而基于时间戳排序是让冲突的事务回滚。
-   基于锁冲突事务的执行次序是根据它们申请锁的顺序,先申请的先执行;而基于时间戳排序是根据特定的时间戳排序规则。 <!--SR:!2022-08-15,4,199-->

基于有效性检查的并发控制与基于时间戳的并发控制对比
#线索 
?
时间戳排序方式不同 <!--SR:!2022-08-30,18,239-->

基于有效性检查的并发控制与基于时间戳的并发控制对比
?
有效性检查通常也是通过对事务的时间戳进行比较完成的,不过和基于时间戳排序的规则不一样。 <!--SR:!2022-08-25,15,239-->


### 3.3 故障与故障恢复技术

#### 3.3.1 为什么需要故障恢复
#线索 
?
事务故障、系统故障 <!--SR:!2022-08-13,4,188-->

事务故障、系统故障
?
-   事务故障::比如非法输入,系统出现死锁,导致事务无法继续执行。 <!--SR:!2022-08-13,4,188-->
-   系统故障::比如由于软件漏洞或硬件错误导致系统崩溃或中止。 <!--SR:!2022-08-22,10,208-->

r日志恢复技术
?
数据库通常以日志的方式记录数据库的操作从而在故障时进行恢复,因而可以称之为日志恢复技术。 <!--SR:!2022-08-14,3,208-->

#### 3.3.2 事务的执行过程以及可能产生的问题

事务的执行过程可以简化如下:
#简化模型
？
1.  系统会为每个事务开辟一个私有工作区
2.  事务读操作将从磁盘中拷贝数据项到工作区中,在执行写操作前所有的更新都作用于工作区中的拷贝。
3.  事务的写操作将把数据输出到内存的缓冲区中,等到合适的时间再由缓冲区管理器将数据写入到磁盘。
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img2018.cnblogs.com/blog/1422237/201811/1422237-20181122103254113-1342077140.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">事务执行过程</div>
</center>

两种修改
#线索 
?
立即修改和延迟修改 <!--SR:!2022-08-15,3,168-->

由于数据库存在立即修改和延迟修改,所以在事务执行过程中可能存在以下情况:
?
-   在事务提交前出现故障,但是事务对数据库的部分修改已经写入磁盘数据库中。这导致了事务的[[DB Card#3 1 2 事务的ACID特性以及实现原理概述|原子性]]被破坏。
-   在系统崩溃前事务已经提交,但数据还在内存缓冲区中,没有写入磁盘。系统恢复时将丢失此次已提交的修改。这是对事务[[DB Card#3 1 2 事务的ACID特性以及实现原理概述|持久性]]的破坏。 <!--SR:!2022-08-13,1,130-->

#### 3.3.3 日志的种类和格式
七种
#线索 
?
重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。 <!--SR:!2022-08-13,1,130-->

两种格式：
#线索 
?
以**记录**为单位的日志文件和以**数据块**为单位的日志文件。 <!--SR:!2022-08-15,4,188-->

以记录为单位的日志文件包括：
？
各个事务的开始（Start Transaction）标记
各个事务的结束（Commit或Rollback）标记
各个事务的所有更新操作。

以数据块为单位的日志文件主要包括：
？
事务标识（标明是哪个事务）
操作的类型（插入、删除或修改）
操作对象（记录内部标识）
更新前数据的旧值（对插入操作而言此项为空值）
更新后数据的新值（对删除操作而言此项为空值）。

关于日志的两条原则：
?
-   1.系统在对数据库进行修改前会在日志文件末尾追加相应的日志记录。
-   2.当一个事务的commit日志记录写入到磁盘成功后,称这个事务已提交,但事务所做的修改可能并未写入磁盘 <!--SR:!2022-08-13,1,148-->

#### 3.3.4 日志恢复的核心思想

-   撤销事务undo::将事务更新的所有数据项恢复为日志中的旧值,事务撤销完毕时将插入一条`<T abort>`记录。 <!--SR:!2022-08-27,16,228-->

-   重做事务redo::将事务更新的所有数据项恢复为日志中的新值。 <!--SR:!2022-08-13,3,168-->

事务正常回滚/因事务故障中止将==进行redo==   <!--SR:!2022-08-13,1,130-->

系统从崩溃中恢复时将先进行==redo再进行undo== <!--SR:!2022-08-13,3,168-->

#### 3.3.5  事务故障中止/正常回滚的恢复流程
?
1.  从后往前扫描日志,对于事务T的每个形如<T,X,V<sub>1</sub>,V<sub>2</sub>>的记录,将旧值V1写入数据项X中。
2.  往日志中写一个特殊的只读记录<T,X,V<sub>1</sub>>,表示将数据项恢复成旧值V1,    这是一个只读的补偿记录,不需要根据它进行undo。
3.  一旦发现了`<T start>`日志记录,就停止继续扫描,并往日志中写一个 <!--SR:!2022-08-13,1,130-->

#### 3.3.6  系统崩溃时的恢复过程(带检查点)

什么是检查点
?
检查点是形如`<checkpoint L>`的特殊的日志记录,L是写入检查点记录时还未提交的事务的集合,系统保证在检查点之前已经提交的事务对数据库的修改已经写入磁盘,不需要进行redo。检查点可以加快恢复的过程。 <!--SR:!2022-08-13,4,188-->

整体过程
#线索 
?
先将日志记录中所有事务的更新按顺序重做一遍,在针对需要撤销的事务按相反的顺序执行其更新操作的撤销操作。 <!--SR:!2022-08-14,3,208-->

两个阶段
#线索 
?
系统崩溃时的恢复过程分为两个阶段:重做阶段和撤销阶段。 <!--SR:!2022-08-13,1,148-->

重做阶段:
?
1.  系统从最后一个检查点开始正向的扫描日志,将要重做的事务的列表undo-list设置为检查点日志记录中的L列表。
2.  发现<T,X,V<sub>1</sub>,V<sub>2</sub>>的更新记录或`<T,X,V>`的补偿撤销记录,就重做该操作。
3.  发现`<T start>`记录,就把T加入到undo-list中。
4.  发现`<T abort>`或`<T commit>`记录,就把T从undo-list中去除。
     <!--SR:!2022-08-13,1,130-->

撤销阶段:
?
1.  系统从尾部开始反向扫描日志   
2.  发现属于undo-list中的事务的日志记录,就执行undo操作
3.  发现undo-list中事务的T的`<T start>`记录,就写入一条`<T abort>`记录,  并把T从undo-list中去除。
4. undo-list为空,则撤销阶段结束 <!--SR:!2022-08-13,4,188-->

### 暂时不知道该放哪的

#### （16） 数据库连接池的作用

#### （17） Mysql的表空间方式，各自特点

##### 表空间的定义及分类
定义：
?
**表空间是数据库系统中数据库逻辑结构与操作系统物理结构之间建立映射的重要存储结构** <!--SR:!2022-08-13,3,171-->

表空间的分类：
#线索
?
共享表空间、独立表空间 <!--SR:!2022-08-13,1,152-->

* 共享表空间：::指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。  <!--SR:!2022-08-14,3,151-->
* 独立表空间：::每一个表都将会生成以独立的文件方式来进行存储。  <!--SR:!2022-08-13,4,191-->

* 独立表空间的优点：::当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； <!--SR:!2022-08-13,1,130-->
* 独立表空间的缺点：::mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题 <!--SR:!2022-08-13,1,130-->

#### （18） 分布式事务

#### （19） 数据库的范式
[数据库设计三大范式 - Ruthless - 博客园](https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html)
 ##### 范式的定义及分类
 
范式的定义
？
为了建立冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为范式。

范式分类

##### 三大范式
#线索 
?
		第一范式(确保每列保持原子性)、
		第二范式(确保表中的每列都和主键相关)、
		第三范式(确保每列都和主键列直接相关,而不是间接相关) <!--SR:!2022-08-13,4,190-->

###### 第一范式(确保每列保持原子性)

定义
?
第一范式是最基本的范式。如果==数据库表中的所有字段值都是不可分解的原子值==，就说明该数据库表满足了第一范式。 <!--SR:!2022-08-16,6,192-->

举例子
? <!--SR:!2022-08-08,2,211-->
第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic002.cnblogs.com/images/2012/270324/2012040114063976.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">符合第一范式的情况</div>
</center>
<!--SR:!2022-08-08,2,212-->

###### 第二范式(确保表中的每列都和主键相关)

定义
?
第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说==在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。== <!--SR:!2022-08-13,4,192-->

举例子
? <!--SR:!2022-08-08,2,211-->
比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic002.cnblogs.com/images/2012/270324/2012040114063976.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">不符合第二范式的情况</div>
</center>
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic002.cnblogs.com/images/2012/270324/2012040114082156.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">符合第二范式的修改</div>
</center> <!--SR:!2022-08-08,2,212-->


###### 第三范式(确保每列都和主键列直接相关,而不是间接相关)

定义
?
第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 <!--SR:!2022-08-13,4,190-->

举例子
? 
比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic002.cnblogs.com/images/2012/270324/2012040114105477.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">符合第san范式的修改</div>
</center>

#####  BCNF范式（确保主键之间没有传递依赖)
主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。

##### （20） 数据的锁的种类，加锁的方式
以MYSQL为例，
三个角度：
#线索 
?
类型、粒度、作用 <!--SR:!2022-08-14,2,190-->

* 按照类型来分有;::乐观锁和悲观锁 <!--SR:!2022-08-20,8,210-->
* 根据粒度来分有::行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁） <!--SR:!2022-08-22,10,210-->
* 根据作用来::分有共享锁（读锁）和排他锁（写锁）。 <!--SR:!2022-08-22,10,210-->


#####  乐观锁和悲观锁

###### 乐观锁

定义：
？
乐观并发控对于并发执行可能冲突的操作,假定其不会真的冲突,允许并发执行,直到真正发生冲突时才去解决冲突,比如让事务回滚。【乐观并发控制】

实现:
#线索 
?
时间戳、版本戳、拷贝后比较 <!--SR:!2022-08-13,1,130-->

时间戳、版本戳、拷贝后比较
?
* 一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。
* 使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。
* 采用时间戳对数据最后修改的时间进行标记。与上一种类似。参见[[DB Card#3 2 3 2 1 基于时间戳的并发控制|基于时间戳的并发控制]] <!--SR:!2022-08-13,1,150-->

原理：
优缺点：

###### 悲观锁

定义：
？
悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。


实现:
？
#线索
悲观锁有行级锁和页级锁两种形式。

悲观锁有行级锁和页级锁两种形式。
?
	[[DB Card#行级锁|行级锁]]对正在使用的单条数据进行锁定，事务完成后释放该行数据，
	[[DB Card#页级锁|页级锁]]则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。 <!--SR:!2022-08-15,4,190-->

原理：
优缺点：

特点：
?
悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。 <!--SR:!2022-08-15,4,190-->

#####  粒度划分的锁
#线索 
?
根据粒度来分有::行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁） <!--SR:!2022-08-20,8,210-->

###### 行级锁
实现:
原理：
优缺点：

特点：
?
行级锁分为[[DB Card#共享锁和排他锁|共享锁和排它锁]]两种 <!--SR:!2022-08-13,1,150-->

###### 页级锁
实现:
原理：
优缺点：

###### 表级锁
实现:
原理：
优缺点：

#####  共享锁和排他锁

[ 据库中的共享锁和排他锁](https://blog.csdn.net/qq_42743933/article/details/81236658)

###### 共享锁

定义：
?
是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。 <!--SR:!2022-08-22,10,210-->

实现:
原理：
?
在查询语句后面增加
``` MySQL 
LOCK IN SHARE MODE

```
MySQL 就会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。 <!--SR:!2022-08-13,1,150-->

优缺点：

共享锁使用：
?
```MySQL
SELECT ... LOCK IN SHARE MODE;

```
<!--SR:!2022-08-13,2,150-->

###### 排他锁

定义：
?
是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据） <!--SR:!2022-08-21,9,210-->

实现:
原理：
?
在查询语句后面增加
```MySQL
FOR UPDATE

```
，MySQL 就会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。 <!--SR:!2022-08-15,3,170-->

优缺点：

排它锁使用：
?
```MySQL
SELECT ... FOR UPDATE;
```
<!--SR:!2022-08-13,1,130-->

##### （22） 分库分表的理解和简介
##### （23） 
##### （24）数据库高并发的解决方案
?
1. [[MySQL Card#高频访问：|增加缓存]]。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。
2. [[MySQL Card#高频访问：|增加数据库索引]]，。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）
3. [[MySQL Card#并发优化：|主从读写分离]]，让主服务器负责写，从服务器负责读。
4. [[MySQL Card#高频访问：|分表分库]]，使得数据库的表尽可能小，提高查询的速度。
5. [[MySQL Card#并发优化：|负载均衡]]，使用分布式架构，分散计算压力。 <!--SR:!2022-08-15,4,190-->


