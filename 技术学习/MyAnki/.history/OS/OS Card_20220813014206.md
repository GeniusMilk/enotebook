#OSCard
#八股文
#Anki

```ActivityHistory
/
```
```toc 
	style: bullet | number | inline (default: bullet) 
	min_depth: number (default: 2) max_depth: number (default: 6) 
	title: string (default: undefined) 
	allow_inconsistent_headings: boolean (default: false) 
	delimiter: string (default: |) 
	varied_style: boolean (default: false) 
```

### （1） 进程与线程
#重点
#### 进程的概念


##### 进程的状态以及转换图
###### 三态模型
#线索 
? 
执行、就绪、阻塞

  三态模型包括三种状态：
  1. 执行：::进程分到CPU时间片，可以执行 <!--SR:!2022-08-18,8,250-->
  2. 就绪：::进程已经就绪，只要分配到[[OS Card|CPU时间片]]，随时可以执行 <!--SR:!2022-08-18,8,250-->
  3. 阻塞：::有IO事件或者等待其他资源 <!--SR:!2022-08-20,10,250-->
  ![](fig/三态模型.png)

###### 五态模型
#线索 
?
新建、就绪、运行、等待、终止 <!--SR:!2022-08-13,2,170-->

  1. 新建态：::进程刚刚创建  、。<!--SR:!2022-08-19,9,250-->
  2. 就绪态：::进程已经就绪，只要分配到CPU时间片，随时可以执行 <!--SR:!2022-08-20,10,250-->
  3. 运行态：
  4. 等待态：出现等待事件
  5. 终止态：进程结束
   ![](fig/五态模型.png)


###### 七态模型
#线索 
?
新建、就绪挂起、就绪、运行、等待、挂起等待、终止 <!--SR:!2022-08-16,4,190-->

  1. 新建态：::进程刚刚创建  <!--SR:!2022-08-19,9,250-->
  2. 就绪挂起态
  3. 就绪态：::进程已经就绪，只要分配到CPU时间片，随时可以执行 <!--SR:!2022-08-20,10,250-->
  4. 运行态：
  5. 等待态：
  6. 挂起等待态：
  7. 终止态：
![](fig/七态模型.png)

##### 进程的执行过程
进程的执行过程是什么样的，执行一个进程需要做哪些工作？
？
参考链接[进程的加载过程](https://blog.csdn.net/qq_38623623/article/details/78306498)
#线索 
进程的执行需要经过三大步骤：编译，链接和装入。

###### 进程的执行需要经过三大步骤

* 编译：::将源代码编译成若干模块
<!--SR:!2022-08-17,5,231-->
* 链接：::将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）
<!--SR:!2022-08-13,2,217-->
* 装入：::将模块装入内存运行，将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少[[|外部碎片]]
<!--SR:!2022-08-13,1,211-->

<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img2020.cnblogs.com/blog/727485/202107/727485-20210705141951122-1696871633.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">  进程载入过程</div>

</center>

###### 程序的链接有三种方式：
#线索 
?
静态链接、装入时动态链接、运行时候动态链接
<!--SR:!2022-08-13,1,171-->

-   静态链接：::在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。
<!--SR:!2022-08-18,6,231-->

-   装入时动态链接：::将用户源程序编译后所得到的一组目标模块，在装入内存时，釆用边装入边链接的链接方式。
<!--SR:!2022-08-18,6,231-->

-   运行时动态链接：::对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接。其优点是便于修改和更新，便于实现对目标模块的共享。
<!--SR:!2022-08-14,2,197-->

###### 内存的装入模块在装入内存时的三种方式
#线索 
?
绝对装入、可重定位装入、动态运行时装入
<!--SR:!2022-08-13,1,171-->

绝对装入（Abosolute Loading Mode）

绝对装入的定义：
在编译时，如果知道程序将驻留在内存的某个位置，编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。

绝对装入的优缺点：

绝对装入的实现：

绝对装入的特点：
- [ ] 由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。  
- [ ] 绝对装入方式只适用于单道程序环境。
- [ ] 程序中所使用的绝对地址,可在编译或汇编时给出，也可由程序员直接赋予
- [ ] 通常情况下在程序中釆用的是符号地址，编译或汇编时再转换为绝对地址

可重定位装入（Relocation Loading Mode）

可重定位装入的定义：
?
在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的,此时应釆用可重定位装入方式。根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对目标程序中指令和数据的修改过程称为重定位，
<!--SR:!2022-08-13,1,219-->

可重定位装入的优缺点：

可重定位装入的实现：

可重定位装入的特点：
- [ ] 一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。
- [ ] 作业一旦进入内存后，在整个运行期间不能在内存中移动，也不能再申请内存空间。
- [ ] 地址变换通常是在装入时一次完成的，所以又称为==静态重定位==，
<!--SR:!2022-08-13,1,177-->

动态运行时装入方式（Dynamic Run-time Loading）

动态运行时装入的定义：

程序在内存中如果发生移动，就需要釆用动态的装入方式。装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。这种方式需要一个[[|TODO重定位寄存器]]的支持，

动态运行时装入的优缺点：

动态运行时装入的实现：

动态运行时装入的特点：
- [ ] 可以将程序分配到不连续的存储区中；
- [ ] 在程序运行之前可以只装入它的部分代码即可投入运行；
- [ ] 在程序运行期间，根据需要动态申请分配内存；
- [ ] 便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。

#TODO 虚内存
#TODO 页面抖动
#TODO 页面调度算法

#### 进程间的通信与调度

##### 进程间的通信
#重点 
进程之间的通信方式主要有六种，包括==管道，信号量，消息队列，信号，共享内存，套接字==
<!--SR:!2022-08-13,1,179-->

###### 管道

管道的原理\\实质：
管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。

管道的底层实现：

管道的优缺点：
优点：==管道是最容易实现的==
<!--SR:!2022-08-13,1,217-->

管道的实例：

###### 信号量

信号量的原理\\实质：
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。[[|TODO等待(P(sv))]]就是将其值减一或者挂起进程，[[|TODO发送(V(sv))]]就是将其值加一或者将进程恢复运行。

信号量的底层实现：

信号量的优缺点：

信号量的实例：

###### 消息队列

消息队列的原理\\实质：
?
消息队列就是一个消息的[[算法与数据结构 Card|TODO链表]]，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。
<!--SR:!2022-08-13,1,211-->

消息队列的底层实现：

消息队列的优缺点：

消息队列的实例：

消息队列与管道通信相比：
?
其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息
<!--SR:!2022-08-13,1,177-->

###### 信号

信号的原理\\实质：
信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 

信号的底层实现：

信号的优缺点：
优点==信号是开销最小的。==
<!--SR:!2022-08-13,2,220-->

信号的实例：

###### 共享内存

共享内存的原理\\实质：
享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。

共享内存的底层实现：

共享内存的优缺点：

优点==共享内存的效率最高==
<!--SR:!2022-08-13,1,177-->

缺点==是没有提供同步机制，需要使用锁等其他机制进行同步。==
<!--SR:!2022-08-13,1,217-->

共享内存的实例：

###### 套接字

套接字的原理\\实质：
?
套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。
<!--SR:!2022-08-17,5,231-->

套接字的底层实现：
套接字的实例：

##### 进程调度的评估
###### 调度性能的衡量
面向用户
#线索 
?
周转时间短
响应时间快
截止时间的保证
优先权
<!--SR:!2022-08-13,1,171-->

周转时间短
==周转时间，指作业从提交系统开始，直到作业完成为止的时间间隔。==周转时间细分包括：
```
1、作业在外存后备队列中的等待时间
2、作业调入内存后创建的相应进程在就绪队列中的等待时间
3、进程在CPU上执行的时间
4、进程等待某些操作完成后的时间
```
其中2、3、4在一个作业的整个处理过程中可能会发生多次。
带权周转时间是指作业周转时间与作业实际运行服务时间的比值。平均周转时间和平均带权周转时间是衡量批处理系统调度算法的重要准则。
<!--SR:!2022-08-14,2,197-->


响应时间快：==从用户提交请求开始，直达系统首次产生响应为止的时间间隔。是衡量**分时系统**调度算法的重要准则。==
<!--SR:!2022-08-17,5,237-->

截止时间的保证：==开始截止时间，指某任务必须开始执行的最迟时间。完成截止时间，指某任务必须完成的最迟时间。==对于比较严格的实时系统，调度算法必须做到这一点，否则后果严重
<!--SR:!2022-08-13,2,217-->

优先权：==[[|批处理系统]]、[[|分时系统]]、[[|实时系统]]都可以优先执行优先级别更高的作业==。
<!--SR:!2022-08-13,1,171-->

 面向系统
#线索 
?
系统吞吐量高
CPU利用率
资源的平衡利用
<!--SR:!2022-08-13,2,219-->

系统吞吐量高
==系统吞吐量，系统在单位时间内所能完成的总的工作量==，它与批处理系统中的作业长短有关。短作业执行时间短，吞吐量高，长作业相反。
<!--SR:!2022-08-13,1,211-->

CPU利用率
资源的平衡利用

###### 调度的相关时间
-   服务时间：作业需要运行的时间
-   完成时间 = 开始时间 + 服务时间
-   等待时间 = 开始时间 - 提交时间
-   周转时间 = 完成时间 - 提交时间
-   带权周转时间 = 周转时间 / 服务时间
-   响应比 = （等待时间 + 服务时间） / 服务时间 = 等待时间/服务时间 + 1

##### 进程的调度方式
#线索 
?
先来先服务 （FCFS，first come first served）
最短作业优先（SJF, Shortest Job First）
最高响应比优先法(HRRN，Highest Response Ratio Next)
时间片轮转算法（RR，Round-Robin）
多级反馈队列(Multilevel Feedback Queue)
<!--SR:!2022-08-13,1,177-->

###### 先来先服务 （FCFS，first come first served）
在所有调度算法中，最简单的是非抢占式的FCFS算法。

算法原理：
进程按照它们请求CPU的顺序使用CPU.就像你买东西去排队，谁第一个排，谁就先被执行，在它执行的过程中，不会中断它。当其他人也想进入内存被执行，就要排队等着，如果在执行过程中出现一些事，他现在不想排队了，下一个排队的就补上。此时如果他又想排队了，只能站到队尾去。

算法优点：
易于理解且实现简单，只需要一个队列(FIFO)，且相当公平

算法缺点：
比较有利于长进程，而不利于短进程，有利于CPU 繁忙的进程，而不利于I/O 繁忙的进程

###### 最短作业优先（SJF, Shortest Job First）
短作业优先（SJF, Shortest Job First）又称为“短进程优先”SPN(Shortest Process Next)；这是对FCFS算法的改进，其目标是减少平均周转时间。

算法原理：
对预计执行时间短的进程优先分派处理机。通常后来的短进程不抢先正在执行的进程。

算法优点：
相比FCFS 算法，该算法可改善平均周转时间和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量。

算法缺点：
对长进程非常不利，可能长时间得不到执行，且未能依据进程的紧迫程度来划分执行的优先级，以及难以准确估计进程的执行时间，从而影响调度性能。

###### 最高响应比优先法(HRRN，Highest Response Ratio Next)
最高响应比优先法(HRRN，Highest Response Ratio Next)是对FCFS方式和SJF方式的一种综合平衡。FCFS方式只考虑每个作业的等待时间而未考虑执行时间的长短，而SJF方式只考虑执行时间而未考虑等待时间的长短。因此，这两种调度算法在某些极端情况下会带来某些不便。HRN调度策略同时考虑每个作业的等待时间长短和估计需要的执行时间长短，从中选出响应比最高的作业投入执行。这样，即使是长作业，随着它等待时间的增加，W / T也就随着增加，也就有机会获得调度执行。这种算法是介于FCFS和SJF之间的一种折中算法。

算法原理：
响应比R定义如下：
 R =(W+T)/T = 1+W/T
其中T为该作业估计需要的执行时间，W为作业在后备状态队列中的等待时间。每当要进行作业调度时，系统计算每个作业的响应比，选择其中R最大者投入执行。

算法优点：
由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于SJF法，从而采用HRRN方式时其吞吐量将小于采用SJF 法时的吞吐量。

算法缺点：
由于每次调度前要计算响应比，系统开销也要相应增加。

###### 时间片轮转算法（RR，Round-Robin）
该算法采用剥夺策略。时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称RR调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。

算法原理：
让就绪进程以FCFS 的方式按时间片轮流使用CPU 的调度方式，即将系统中所有的就绪进程按照FCFS 原则，排成一个队列，每次调度时将CPU 分派给队首进程，让其执行一个时间片，时间片的长度从几个ms 到几百ms。在一个时间片结束时，发生时钟中断，调度程序据此暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程，进程可以未使用完一个时间片，就出让CPU（如阻塞）。

算法优点：
时间片轮转调度算法的特点是简单易行、平均响应时间短。

算法缺点：
不利于处理紧急作业。在时间片轮转算法中，时间片的大小对系统性能的影响很大，因此时间片的大小应选择恰当

时间片大小的确定:
1.系统对响应时间的要求
2.就绪队列中进程的数目
3.系统的处理能力

###### 多级反馈队列(Multilevel Feedback Queue)
多级反馈队列调度算法是一种CPU处理机调度算法，UNIX操作系统采取的便是这种调度算法。
多级反馈队列调度算法描述：
　　1、进程在进入待调度的队列等待时，首先进入优先级最高的Q1等待。
　　2、首先调度优先级高的队列中的进程。若高优先级中队列中已没有调度的进程，则调度次优先级队列中的进程。例如：
Q1,Q2,Q3三个队列，只有在Q1中没有进程等待时才去调度Q2，同理，只有Q1,Q2都为空时才会去调度Q3。
　　3、对于同一个队列中的各个进程，按照时间片轮转法调度。比如Q1队列的时间片为N，那么Q1中的作业在经历了N个时间片后若还没有完成，则进入Q2队列等待，若Q2的时间片用完后作业还不能完成，一直进入下一级队列，直至完成。
　　4、在低优先级的队列中的进程在运行时，又有新到达的作业，那么在运行完这个时间片后，CPU马上分配给新到达的作业（抢占式）。
　　在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。

#### 进程的管理

##### 孤儿进程和僵尸进程
参考链接：
[孤儿进程与僵尸进程[总结] - Rabbit_Dale - 博客园 (cnblogs.com)](https://www.cnblogs.com/Anker/p/3271773.html)
###### 孤儿进程和僵尸进程的基本概念
?
* 孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。
* 僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。
<!--SR:!2022-08-14,2,202-->

###### 孤儿进程和僵尸进程的问题及危害

unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: ==在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。==
<!--SR:!2022-08-13,1,183-->

孤儿进程危害场景：

僵尸进程危害场景：
?
如果进程不调用`wait / waitpid`的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 
<!--SR:!2022-08-13,1,178-->

###### 僵尸进程解决办法
?
僵死进程并不是问题的根源，根源是产生出僵尸进程的那个父进程。因此，当消灭系统中大量的僵死进程时，答案就==是把产生大量僵尸进程的那个父进程就是通过[[|TODOkill]]发送SIGTERM或者SIGKILL信号啦杀掉==。kill掉父进程，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，
<!--SR:!2022-08-13,1,182-->


##### PCB解析
参考链接[(PCB和进程控制_冰炭不投day的博客-CSDN博客_操作系统pcb的主要内容](https://blog.csdn.net/qq_38499859/article/details/80057427)
###### PCB概述
?
进程控制块(Processing Control Block),是操作系统核心中一种数据结构，主要表示进程状态，其作用是使一个程序成为一个能够独立运行的基本单位，并且可以并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理。PCB通常是占用系统内存中一块连续的内存空间，存放着操作系统用于描述进程情况及控制进程运行的全部信息。
<!--SR:!2022-08-13,2,217-->

###### 进程控制块中的信息
#线索 
?
进程标识符、处理机状态、进程调度信息、进程控制信息
<!--SR:!2022-08-13,1,177-->

a.进程标识符
?
内部标识符：::操作系统为每一个进程赋予的唯一数字标识符，系统使用
<!--SR:!2022-08-14,2,198-->
外部标识符：::由创建者提供，通常有字母与数字组成，往往是由用户(进程)在访问该进程时使用。描述进程的家族关系，设置父进程标识及子进程标识，还可设置用户标识，以指示拥有该进程的用户。
<!--SR:!2022-08-13,1,178-->

b.处理机状态
?
主要是由处理机的各种寄存器中的内容组成的，处理机被中断时，所有这些信息都必须保存在PCB中，以便在该进程重新执行时，能从断点继续执行。
这些寄存器包括: 通用寄存器、指令计数器、程序状态字PSW、用户栈指针
<!--SR:!2022-08-13,1,177-->

c.进程调度信息
?
进程状态
进程优先级
进程调度所需要的其他信息，比如已等待CPU的时间综合，进程一直想的时间总和。
事件，指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因
<!--SR:!2022-08-13,1,182-->

d.进程控制信息
?
程序和数据的地址
进程同步和通信机制
资源清单
链接指针
<!--SR:!2022-08-13,1,182-->

###### 进程控制块的作用
?
PCB 可以被操作系统中的多个模块读或修改，如被调度程序、资源分配程序、中断处理程序以及监督和分析程序等读或修改。 OS是根据 PCB来对 并发执行的进程进行控制和管理，所以说PCB是操作系统中最重要的记录型数据结构
```text
1、作为独立运行基本单位的标志  
2、能实现间断性运行方式  
3、提供进程管理所需要的信息  
4、提供进程调度所需要的信息  
5、实现与其他进程的同步与通信

```
<!--SR:!2022-08-13,1,177-->

###### 进程控制块的组织方式
#线索 
?
[[算法与数据结构 Card|线性方式]]、[[算法与数据结构 Card|链式方式]]、[[算法与数据结构 Card|索引方式]]
<!--SR:!2022-08-13,2,217-->

a.线性方式：
?
即将系统中所有的PCB都组长在一张线性表中，将该表的首地址存放在内存的一个专用区域中。适合于系统中进程数目不多的情况
<!--SR:!2022-08-14,2,202-->

b.链接方式：
?
该方式是线性表方式的改进，系统按照进程的状态分别建立就绪索引表、阻塞索引表等。
<!--SR:!2022-08-13,1,177-->

c.索引方式：
?
系统按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列等。
<!--SR:!2022-08-13,1,182-->

[[Linux Card|TODO Linux 下的进程控制块]]
[[Unix Card|TODO Unix 下的进程控制块]]
[[Windows Card|TODO Windows 下的进程控制块]]

##### 如何安全的结束进程

#### 线程的概念
##### 线程间的通信
#线索 
?
* 使用全局变量
* 使用信号机制
* 使用事件
<!--SR:!2022-08-13,1,177-->

###### 使用全局变量实现线程间的通信

###### 使用信号机制实现线程间的通信

###### 使用事件实现线程间的通信

##### 线程间的同步

###### 数据间的制约关系
#线索 
?
直接制约、间接制约
<!--SR:!2022-08-14,2,197-->

直接制约关系，==即一个线程的处理结果，为另一个线程的输入，因此线程之间直接制约着，这种关系可以称之为同步关系。==  
<!--SR:!2022-08-14,2,198-->

间接制约关系，==即两个线程需要访问同一资源，该资源在同一时刻只能被一个线程访问，这种关系称之为线程间对资源的互斥访问，某种意义上说互斥是一种制约关系更小的同步==
<!--SR:!2022-08-14,2,197-->

线程间的同步方式
#线索 
?
临界区、互斥量、信号量、事件
<!--SR:!2022-08-13,1,182-->

###### 临界区

临界区的定义：
?
临界区对应着一个CcriticalSection对象，当线程需要访问保护数据时，调用EnterCriticalSection函数；当对保护数据的操作完成之后，调用LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以夺取临界区对象并访问受保护的数据。
<!--SR:!2022-08-13,1,177-->

临界区的注意点：
?
关键段对象会记录拥有该对象的线程句柄即其具有“线程所有权”概念，即进入代码段的线程在leave之前，可以重复进入关键代码区域。所以关键段可以用于线程间的互斥，但不可以用于同步（同步需要在一个线程进入，在另一个线程leave）
<!--SR:!2022-08-13,1,182-->

###### 互斥量

互斥量的定义：
?
互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核对象），不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程间实现同步，从而实现资源的安全共享。  
<!--SR:!2022-08-13,1,177-->

互斥量的注意点：
?
1、互斥量由于也有线程所有权的概念，故也只能进行线程间的资源互斥访问，不能由于线程同步；  
2、由于互斥量是内核对象，因此其可以进行进程间通信，同时还具有一个很好的特性，就是在进程间通信时完美的解决了"遗弃"问题
<!--SR:!2022-08-13,1,177-->

###### 信号量

信号量的定义：
?
信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程访问同一个资源，PV操作  
<!--SR:!2022-08-13,1,177-->

信号量的注意点：
?
事件可以完美解决线程间的同步问题，同时信号量也属于内核对象，可用于进程间的通信
<!--SR:!2022-08-13,1,177-->

###### 事件

事件的定义：
?
事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。由SetEvent()来触发，由ResetEvent()来设成未触发。  
<!--SR:!2022-08-13,1,182-->

事件的注意点：
事件是内核对象,可以解决线程间同步问题，因此也能解决互斥问题

事件的分类：::事件分为手动置位事件和自动置位事件。
<!--SR:!2022-08-13,1,177-->

#### 进程与线程的区别与联系
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic1.zhimg.com/80/v2-7d100e1d833d74e4fe20ce21c48aedd8_720w.jpg"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">  进程与线程比较 </div>

</center>

##### 同一个进程内的线程会共享什么资源？
?
* 该进程的地址空间
* 全局变量
* 堆空间
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://raw.githubusercontent.com/vorshen/blog/master/thread/assets/process_thread.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">  进程与线程内存示意图 </div>
<!--SR:!2022-08-13,1,177-->

</center>


##### 进程与线程的区别

#线索
基本单元、相互间的关系、资源开销、崩溃时的影响

1. 进程::是对运行时程序的封装，是系统进行资源分配和调度的基本单元， <!--SR:!2022-08-17,6,243-->
	线程::是进程的子任务，是CPU分配和调度的基本单元。 <!--SR:!2022-08-13,2,203-->

2. 相互关系==一个进程可以有多个线程，但是一个线程只能属于一个进程。== <!--SR:!2022-08-16,5,243-->

3. 进程的创建需要系统==分配内存和CPU，文件句柄等资源，==销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。 <!--SR:!2022-08-13,1,203-->

4. 进程之间不会相互影响；而一个线程崩溃==会导致进程崩溃，从而影响同一个进程里面的其他线程。== <!--SR:!2022-08-14,2,223-->

##### 进程与线程的联系
进程与线程之间的关系：==线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。==
<!--SR:!2022-08-18,6,231-->

#### 多线程与多进程
##### 什么时候用多进程，什么时候用多线程
参考链接：
[ 多线程还是多进程的选择及区别_Fireplusplus的博客-CSDN博客](https://blog.csdn.net/qq_33724710/article/details/52510600?utm_source=copy)
#线索 
?
频繁修改、计算量、相关性、多分布
<div class="table-box">
<!--SR:!2022-08-13,1,190-->

    <table border="1" cellpadding="0" cellspacing="0"

        style="font-family:Arial; font-size:14px; line-height:26px; color:rgb(255,255,255)">

        <tbody>

            <tr>

                <td>

                    <p align="center"><strong>对比维度</strong></p>

                </td>

                <td>

                    <p align="center"><strong>多进程</strong></p>

                </td>

                <td>

                    <p align="center"><strong>多线程</strong></p>

                </td>

                <td>

                    <p align="center"><strong>总结</strong></p>

                </td>

            </tr>

            <tr>

                <td>

                    <p>数据共享、同步</p>

                </td>

                <td>

                    <p>数据共享复杂，需要用IPC；数据是分开的，同步简单</p>

                </td>

                <td>

                    <p>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</p>

                </td>

                <td>

                    <p>各有优势</p>

                </td>

            </tr>

            <tr>

                <td>

                    <p>内存、CPU</p>

                </td>

                <td>

                    <p>占用内存多，切换复杂，CPU利用率低</p>

                </td>

                <td>

                    <p>占用内存少，切换简单，CPU利用率高</p>

                </td>

                <td>

                    <p>线程占优</p>

                </td>

            </tr>

            <tr>

                <td>

                    <p>创建销毁、切换</p>

                </td>

                <td>

                    <p>创建销毁、切换复杂，速度慢</p>

                </td>

                <td>

                    <p>创建销毁、切换简单，速度很快</p>

                </td>

                <td>

                    <p>线程占优</p>

                </td>

            </tr>

            <tr>

                <td>

                    <p>编程、调试</p>

                </td>

                <td>

                    <p>编程简单，调试简单</p>

                </td>

                <td>

                    <p>编程复杂，调试复杂</p>

                </td>

                <td>

                    <p>进程占优</p>

                </td>

            </tr>

            <tr>

                <td>

                    <p>可靠性</p>

                </td>

                <td>

                    <p>进程间不会互相影响</p>

                </td>

                <td>

                    <p>一个线程挂掉将导致整个进程挂掉</p>

                </td>

                <td>

                    <p>进程占优</p>

                </td>

            </tr>

            <tr>

                <td>

                    <p>分布式</p>

                </td>

                <td>

                    <p>适应于<span style="color:blue">多核、多机</span>分布式；如果一台机器不够，扩展到多台机器比较简单</p>

                </td>

                <td>

                    <p>适应于<span style="color:blue">多核</span>分布式</p>

                </td>

                <td>

                    <p>进程占优</p>

                </td>

            </tr>

        </tbody>

    </table>

</div>
<!--SR:!2022-08-12,1,197-->

* 频繁修改：需要频繁创建和销毁的优先使用**多线程**
* 计算量：需要大量计算的优先使用**多线程**  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点
* 相关性：任务间相关性比较强的用**多线程**，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。
* 多分布：可能要扩展到多机分布的用**多进程**，多核分布的用**多线程**。


### OS的内存管理
#### 内存的基本概念
参考链接 [OS--内存管理](https://www.cnblogs.com/peterYong/p/6556619.html#_label1)

##### 内存管理的概念
内存管理(Memory Management)是操作系统设计中最重要和最复杂的内容之一。虽然计算机硬件一直在飞速发展，内存容量也在不断增长，但是仍然不可能将所有用户进程和系统所需要的全部程序和数据放入主存中，所以操作系统必须将内存空间进行合理地划分和有效地动态分配。操作系统对内存的划分和动态分配，就是内存管理的概念。  
有效的内存管理在多道程序设计中非常重要，不仅方便用户使用存储器、提高内存利用率，还可以通过虚拟技术从逻辑上扩充存储器。  

内存管理的功能有：
#线索 
?
内存空间的分配与回收、地址转换、内存的扩充、存储保护
<!--SR:!2022-08-13,1,177-->

内存管理的功能有：
?
-   内存空间的分配与回收：::由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。
<!--SR:!2022-08-13,2,211-->
-   地址转换：::在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。
<!--SR:!2022-08-13,1,217-->
-   内存空间的扩充：::利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。
<!--SR:!2022-08-13,1,179-->
-   存储保护：::保证各道作业在各自的存储空间内运行，.互不干扰
<!--SR:!2022-08-13,1,219-->

![[OS Card#进程的执行过程|涉及到进程的执行过程]]

##### 逻辑地址空间与物理地址空间
###### 逻辑地址空间
#定义
编译后，每个目标模块都是从0号单元开始编址，称为该目标模块的相对地址（或逻辑地址)。

###### 物理地址空间
#定义
物理地址空间是指内存中物理单元的集合，

它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为[[|TODO地址重定位]]。

#### 内存保护
内存保护的目的：
内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。
内存保护的实现
通过釆用重定位寄存器和界地址寄存器来实现这种保护。

重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址值。每个逻辑地址值必须小于界地址寄存器；内存管理机构动态地将逻辑地址与界地址寄存器进行比较，如果未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，。  
  
当CPU调度程序选择进程执行时，派遣程序会初始化重定位寄存器和界地址寄存器。每一个逻辑地址都需要与这两个寄存器进行核对，以保证操作系统和其他用户程序及数据不被该进程的运行所影响。
<center>
	<img style="border-radius: 0.3125em;
	 box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img2020.cnblogs.com/blog/727485/202107/727485-20210705142045078-632248608.png"> 
	 <br> 
	 <div style="color:orange; border-bottom: 1px solid #d9d9d9; 
	 display: inline-block;
	 color: #999; 
	 padding: 2px;">  重定位和界地址寄存器</div>

</center>
#### 内存覆盖与内存交换

##### 内存覆盖
###### 内存覆盖解决的问题：

###### 内存覆盖的基本思想：
由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此==可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。==
<!--SR:!2022-08-13,1,217-->

###### 内存覆盖的特点：

##### 内存交换
###### 内存交换解决的问题：
###### 内存交换的基本思想：
把处于[[OS Card#进程的状态以及转换图|等待状态]]（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出；把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。中级调度就是釆用交换技术。

###### 内存交换的特点：
两个阶段
换出、换入

###### 内存交换注意的问题：
- [ ] 交换需要备份存储，通常是快速磁盘。它必须足够大，并且提供对这些内存映像的直接访问。
- [ ] 为了有效使用CPU，需要每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间。转移时间与所交换的内存空间成正比。
- [ ] 如果换出进程，必须确保该进程是完全处于空闲状态。
- [ ] 交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用就可能很快。
- [ ] 交换通常在有许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停。
- [ ] 普通的交换使用不多，但交换策略的某些变种在许多系统中（如UNIX系统）仍发挥作用。

##### 内存覆盖与内存交换的比较
交换技术主要是==在不同进程（或作业）之间进行==
覆盖技术用于==同一个程序或进程中==
由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾，现代操作系统是通过==虚拟内存==技术来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。
<!--SR:!2022-08-13,1,220!2022-08-13,1,219!2022-08-13,1,211-->

#### 内存分配管理方式
##### 内存连续分配管理方式
##### 内存非连续分配管理方式

#线索 
操作系统的内存管理包括物理内存管理和虚拟内存管理

* 物理内存管理包括
#线索 
?
==交换与覆盖，分页管理，分段管理和段页式管理==等；
<!--SR:!2022-08-13,2,217-->

* 虚拟内存管理包括
#线索 
?
==虚拟内存的概念，页面置换算法，页面分配策略==等；
<!--SR:!2022-08-13,1,177-->

#TODO [Linux 虚拟内存和物理内存的理解(转) - Przz - 博客园 (cnblogs.com)](https://www.cnblogs.com/Przz/p/6876988.html)

##### 虚拟内存
###### 虚拟内存的定义
###### 虚拟内存的相关概念
?
#线索
虚拟存储空间，磁盘空间，内存空间
<!--SR:!2022-08-13,1,183-->

###### 虚拟内存的

##### 物理内存
###### 物理内存的内核映射
###### 物理内存的管理机制
###### 物理内存的分配

### 临时放在这里的
#### （17） 内核空间和用户空间是怎样区分的
在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。

内核空间中存放的是==内核代码和数据==，
进程的用户空间中存放的是==用户程序的代码和数据==。
<!--SR:!2022-08-13,2,223!2022-08-13,2,223-->

#### （20） 异常和中断的区别
#### （21） 一般情况下在Linux/windows平台下栈空间的大小
在Linux下栈空间通常是8M，Windows下是1M
#### （23）服务器高并发的解决方案
#线索 
?
应用数据与静态资源分离
客户端缓存
集群和分布式
反向代理
<!--SR:!2022-08-13,1,177-->

#### （24）协程（高频）
##### 协程的定义
?
协程和微线程是一个东西。
协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。
这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。
<!--SR:!2022-08-13,1,177-->

##### 协程的底层实现，怎么使用协程？
协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。